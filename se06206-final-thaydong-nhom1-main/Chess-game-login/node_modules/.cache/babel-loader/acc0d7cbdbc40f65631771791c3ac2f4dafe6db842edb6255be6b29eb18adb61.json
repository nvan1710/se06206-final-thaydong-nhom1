{"ast":null,"code":"export const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board, turn, lastMove) => {\n  console.log(`Move check: ${piece} from (${fromRow},${fromCol}) to (${toRow},${toCol}), Turn: ${turn}`);\n  if (fromRow === toRow && fromCol === toCol) return false;\n  const isWhite = \"♙♖♘♗♕♔\".includes(piece);\n  if (turn === \"white\" && !isWhite || turn === \"black\" && isWhite) return false;\n  const targetPiece = board[toRow][toCol];\n  const isTargetWhite = targetPiece && \"♙♖♘♗♕♔\".includes(targetPiece);\n  if (targetPiece && isWhite === isTargetWhite) return false;\n  switch (piece) {\n    case \"♙\":\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, true, lastMove);\n    case \"♟\":\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, false, lastMove);\n    case \"♖\":\n    case \"♜\":\n      return isValidRookMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♘\":\n    case \"♞\":\n      return isValidKnightMove(toCol - fromCol, toRow - fromRow);\n    case \"♗\":\n    case \"♝\":\n      return isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♕\":\n    case \"♛\":\n      return isValidQueenMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♔\":\n    case \"♚\":\n      return isValidKingMove(fromRow, fromCol, toRow, toCol, board);\n    default:\n      return false;\n  }\n};\n\n// 🏇 Knight move\nconst isValidKnightMove = (dx, dy) => {\n  return Math.abs(dx) === 2 && Math.abs(dy) === 1 || Math.abs(dx) === 1 && Math.abs(dy) === 2;\n};\n\n// 🏰 Rook move (straight lines)\nconst isValidRookMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// 🏹 Bishop move (diagonal)\nconst isValidBishopMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// 👑 Queen move (Rook + Bishop combined)\nconst isValidQueenMove = (fromRow, fromCol, toRow, toCol, board) => {\n  return isValidRookMove(fromRow, fromCol, toRow, toCol, board) || isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ⚔ King move (1 square + Castling)\nconst isValidKingMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) <= 1 && Math.abs(fromRow - toRow) <= 1) return true;\n  return isValidCastling(fromRow, fromCol, toRow, toCol, board);\n};\n\n// 🏰 Castling\nconst isValidCastling = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) !== 2 || fromRow !== toRow) return false;\n  return true;\n};\n\n// 📏 Check if path is clear\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x]) return false;\n    x += dx;\n    y += dy;\n  }\n  return true;\n};\n\n// 🔎 Check detection\nexport const isKingInCheck = (turn, board) => {\n  let kingPos = null;\n  board.forEach((row, rIdx) => row.forEach((piece, cIdx) => {\n    if (turn === \"white\" && piece === \"♔\" || turn === \"black\" && piece === \"♚\") {\n      kingPos = {\n        row: rIdx,\n        col: cIdx\n      };\n    }\n  }));\n  return board.some((row, rIdx) => row.some((piece, cIdx) => {\n    if (piece && (turn === \"white\" && \"♟♜♞♝♛♚\".includes(piece) || turn === \"black\" && \"♙♖♘♗♕♔\".includes(piece))) {\n      return isValidMove(piece, rIdx, cIdx, kingPos.row, kingPos.col, board, turn);\n    }\n    return false;\n  }));\n};\n\n// 🏆 Checkmate detection\nexport const isCheckmate = (turn, board) => {\n  if (!isKingInCheck(turn, board)) return false;\n  return getAllPossibleMoves(turn, board).length === 0;\n};\n\n// 🤝 Stalemate detection\nexport const isStalemate = (turn, board) => {\n  if (isKingInCheck(turn, board)) return false;\n  return getAllPossibleMoves(turn, board).length === 0;\n};","map":{"version":3,"names":["isValidMove","piece","fromRow","fromCol","toRow","toCol","board","turn","lastMove","console","log","isWhite","includes","targetPiece","isTargetWhite","isValidPawnMove","isValidRookMove","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","dx","dy","Math","abs","isPathClear","isValidCastling","sign","x","y","isKingInCheck","kingPos","forEach","row","rIdx","cIdx","col","some","isCheckmate","getAllPossibleMoves","length","isStalemate"],"sources":["/root/se06206-final-thaydong-nhom1/Chess-game-login/src/utils/moveRules.js"],"sourcesContent":["export const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board, turn, lastMove) => {\n  console.log(`Move check: ${piece} from (${fromRow},${fromCol}) to (${toRow},${toCol}), Turn: ${turn}`);\n\n  if (fromRow === toRow && fromCol === toCol) return false;\n\n  const isWhite = \"♙♖♘♗♕♔\".includes(piece);\n  if ((turn === \"white\" && !isWhite) || (turn === \"black\" && isWhite)) return false;\n\n  const targetPiece = board[toRow][toCol];\n  const isTargetWhite = targetPiece && \"♙♖♘♗♕♔\".includes(targetPiece);\n\n  if (targetPiece && isWhite === isTargetWhite) return false;\n\n  switch (piece) {\n    case \"♙\": return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, true, lastMove);\n    case \"♟\": return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, false, lastMove);\n    case \"♖\": case \"♜\": return isValidRookMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♘\": case \"♞\": return isValidKnightMove(toCol - fromCol, toRow - fromRow);\n    case \"♗\": case \"♝\": return isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♕\": case \"♛\": return isValidQueenMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♔\": case \"♚\": return isValidKingMove(fromRow, fromCol, toRow, toCol, board);\n    default: return false;\n  }\n};\n\n// 🏇 Knight move\nconst isValidKnightMove = (dx, dy) => {\n  return (Math.abs(dx) === 2 && Math.abs(dy) === 1) || (Math.abs(dx) === 1 && Math.abs(dy) === 2);\n};\n\n// 🏰 Rook move (straight lines)\nconst isValidRookMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// 🏹 Bishop move (diagonal)\nconst isValidBishopMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// 👑 Queen move (Rook + Bishop combined)\nconst isValidQueenMove = (fromRow, fromCol, toRow, toCol, board) => {\n  return isValidRookMove(fromRow, fromCol, toRow, toCol, board) || isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ⚔ King move (1 square + Castling)\nconst isValidKingMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) <= 1 && Math.abs(fromRow - toRow) <= 1) return true;\n  return isValidCastling(fromRow, fromCol, toRow, toCol, board);\n};\n\n// 🏰 Castling\nconst isValidCastling = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) !== 2 || fromRow !== toRow) return false;\n  return true;\n};\n\n// 📏 Check if path is clear\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x]) return false;\n    x += dx;\n    y += dy;\n  }\n  return true;\n};\n\n// 🔎 Check detection\nexport const isKingInCheck = (turn, board) => {\n  let kingPos = null;\n  board.forEach((row, rIdx) =>\n    row.forEach((piece, cIdx) => {\n      if ((turn === \"white\" && piece === \"♔\") || (turn === \"black\" && piece === \"♚\")) {\n        kingPos = { row: rIdx, col: cIdx };\n      }\n    })\n  );\n\n  return board.some((row, rIdx) =>\n    row.some((piece, cIdx) => {\n      if (piece && ((turn === \"white\" && \"♟♜♞♝♛♚\".includes(piece)) || (turn === \"black\" && \"♙♖♘♗♕♔\".includes(piece)))) {\n        return isValidMove(piece, rIdx, cIdx, kingPos.row, kingPos.col, board, turn);\n      }\n      return false;\n    })\n  );\n};\n\n// 🏆 Checkmate detection\nexport const isCheckmate = (turn, board) => {\n  if (!isKingInCheck(turn, board)) return false;\n  return getAllPossibleMoves(turn, board).length === 0;\n};\n\n// 🤝 Stalemate detection\nexport const isStalemate = (turn, board) => {\n  if (isKingInCheck(turn, board)) return false;\n  return getAllPossibleMoves(turn, board).length === 0;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}