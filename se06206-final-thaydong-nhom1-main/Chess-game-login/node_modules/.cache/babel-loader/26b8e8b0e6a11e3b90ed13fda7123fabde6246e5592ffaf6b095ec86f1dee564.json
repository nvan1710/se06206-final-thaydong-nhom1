{"ast":null,"code":"let currentTurn = true; // true l√† Tr·∫Øng, false l√† ƒêen\n\nexport const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow === toRow && fromCol === toCol) return false; // Kh√¥ng th·ªÉ ƒë·ª©ng y√™n\n\n  // üèÜ Ki·ªÉm tra n∆∞·ªõc ƒëi c√≥ l√†m vua b·ªã chi·∫øu kh√¥ng\n  const newBoard = board.map(row => [...row]);\n  newBoard[toRow][toCol] = piece;\n  newBoard[fromRow][fromCol] = \"\";\n  const isWhite = \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece); // Ki·ªÉm tra qu√¢n tr·∫Øng\n  if (isKingInCheck(newBoard, isWhite)) {\n    console.log(\"üö´ N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá: Vua b·ªã chi·∫øu!\");\n    return false; // Kh√¥ng ƒë∆∞·ª£c ƒëi n·∫øu vua b·ªã chi·∫øu\n  }\n  return true;\n};\n\n// ‚úÖ T·ªët (Pawn) - s·ª≠a l·∫°i ki·ªÉm tra nh·∫£y 2 √¥ & ƒÉn ch√©o h·ª£p l·ªá\nconst isValidPawnMove = (fromRow, fromCol, toRow, toCol, board, isWhite) => {\n  const direction = isWhite ? -1 : 1; // Tr·∫Øng ƒëi l√™n (-1), ƒêen ƒëi xu·ªëng (+1)\n  const startRow = isWhite ? 6 : 1;\n  const dy = toRow - fromRow;\n  const dx = Math.abs(toCol - fromCol);\n  const targetPiece = board[toRow][toCol];\n\n  // Di chuy·ªÉn th·∫≥ng (kh√¥ng ƒë∆∞·ª£c c√≥ qu√¢n c·ªù ch·∫∑n)\n  if (dx === 0 && !targetPiece) {\n    if (dy === direction) return true; // ƒêi 1 √¥ h·ª£p l·ªá\n    if (fromRow === startRow && dy === 2 * direction && !board[fromRow + direction][toCol]) {\n      return true; // ƒêi 2 √¥ t·ª´ v·ªã tr√≠ ban ƒë·∫ßu h·ª£p l·ªá (kh√¥ng nh·∫£y qua qu√¢n c·ªù)\n    }\n  }\n\n  // ƒÇn qu√¢n ch√©o (ch·ªâ khi c√≥ qu√¢n ƒë·ªãch ·ªü √¥ ƒë√≠ch)\n  if (dx === 1 && dy === direction && targetPiece) {\n    return true;\n  }\n  return false;\n};\n\n// ‚úÖ Xe (Rook) - ƒë·∫£m b·∫£o c√≥ th·ªÉ ƒÉn qu√¢n ƒë·ªëi th·ªß h·ª£p l·ªá\nconst isValidRookMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ‚úÖ M√£ (Knight) - kh√¥ng c·∫ßn s·ª≠a (n∆∞·ªõc ƒëi ƒë√£ ƒë√∫ng)\nconst isValidKnightMove = (dx, dy) => {\n  return Math.abs(dx) === 2 && Math.abs(dy) === 1 || Math.abs(dx) === 1 && Math.abs(dy) === 2;\n};\n\n// ‚úÖ T∆∞·ª£ng (Bishop) - ƒë·∫£m b·∫£o kh√¥ng b·ªã ch·∫∑n ƒë∆∞·ªùng ƒëi\nconst isValidBishopMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ‚úÖ H·∫≠u (Queen) - k·∫øt h·ª£p Xe & T∆∞·ª£ng\nconst isValidQueenMove = (fromRow, fromCol, toRow, toCol, board) => {\n  return isValidRookMove(fromRow, fromCol, toRow, toCol, board) || isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ‚úÖ Vua (King) - gi·ªØ nguy√™n\nconst isValidKingMove = (dx, dy) => {\n  return Math.abs(dx) <= 1 && Math.abs(dy) <= 1;\n};\n\n// ‚úÖ S·ª≠a l·∫°i ki·ªÉm tra ƒë∆∞·ªùng ƒëi `isPathClear()`\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x] !== \"\") return false; // N·∫øu c√≥ qu√¢n c·ªù ch·∫∑n ƒë∆∞·ªùng, kh√¥ng h·ª£p l·ªá\n    x += dx;\n    y += dy;\n  }\n  return true;\n};\nconst findKingPosition = (board, isWhite) => {\n  const king = isWhite ? \"‚ôî\" : \"‚ôö\";\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] === king) return {\n        row,\n        col\n      };\n    }\n  }\n  return null;\n};\nconst isKingInCheck = (board, isWhite) => {\n  const kingPos = findKingPosition(board, isWhite);\n  if (!kingPos) return false; // Kh√¥ng t√¨m th·∫•y vua (tr√°nh l·ªói)\n\n  const {\n    row: kingRow,\n    col: kingCol\n  } = kingPos;\n\n  // Duy·ªát qua to√†n b·ªô b√†n c·ªù ƒë·ªÉ t√¨m qu√¢n ƒë·ªëi ph∆∞∆°ng c√≥ th·ªÉ chi·∫øu vua\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (!piece) continue; // √î tr·ªëng b·ªè qua\n\n      const isEnemy = \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece) !== isWhite;\n      if (isEnemy && isValidMove(piece, row, col, kingRow, kingCol, board)) {\n        return true; // N·∫øu c√≥ qu√¢n ƒë·ªãch c√≥ th·ªÉ ƒëi ƒë·∫øn v·ªã tr√≠ vua, vua ƒëang b·ªã chi·∫øu\n      }\n    }\n  }\n  return false; // Kh√¥ng c√≥ qu√¢n n√†o chi·∫øu vua\n};","map":{"version":3,"names":["currentTurn","isValidMove","piece","fromRow","fromCol","toRow","toCol","board","newBoard","map","row","isWhite","includes","isKingInCheck","console","log","isValidPawnMove","direction","startRow","dy","dx","Math","abs","targetPiece","isValidRookMove","isPathClear","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","sign","x","y","findKingPosition","king","col","kingPos","kingRow","kingCol","isEnemy"],"sources":["D:/se06206-final-thaydong-nhom1-main/se06206-final-thaydong-nhom1-main/Chess-game-login/src/utils/moveRules.js"],"sourcesContent":["\nlet currentTurn = true; // true l√† Tr·∫Øng, false l√† ƒêen\n\nexport const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow === toRow && fromCol === toCol) return false; // Kh√¥ng th·ªÉ ƒë·ª©ng y√™n\n\n  // üèÜ Ki·ªÉm tra n∆∞·ªõc ƒëi c√≥ l√†m vua b·ªã chi·∫øu kh√¥ng\n  const newBoard = board.map(row => [...row]);\n  newBoard[toRow][toCol] = piece;\n  newBoard[fromRow][fromCol] = \"\";\n\n  const isWhite = \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece); // Ki·ªÉm tra qu√¢n tr·∫Øng\n  if (isKingInCheck(newBoard, isWhite)) {\n    console.log(\"üö´ N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá: Vua b·ªã chi·∫øu!\");\n    return false; // Kh√¥ng ƒë∆∞·ª£c ƒëi n·∫øu vua b·ªã chi·∫øu\n  }\n\n  return true;\n};\n\n\n\n\n\n\n// ‚úÖ T·ªët (Pawn) - s·ª≠a l·∫°i ki·ªÉm tra nh·∫£y 2 √¥ & ƒÉn ch√©o h·ª£p l·ªá\nconst isValidPawnMove = (fromRow, fromCol, toRow, toCol, board, isWhite) => {\n  const direction = isWhite ? -1 : 1; // Tr·∫Øng ƒëi l√™n (-1), ƒêen ƒëi xu·ªëng (+1)\n  const startRow = isWhite ? 6 : 1;\n  const dy = toRow - fromRow;\n  const dx = Math.abs(toCol - fromCol);\n  const targetPiece = board[toRow][toCol];\n\n  // Di chuy·ªÉn th·∫≥ng (kh√¥ng ƒë∆∞·ª£c c√≥ qu√¢n c·ªù ch·∫∑n)\n  if (dx === 0 && !targetPiece) {\n      if (dy === direction) return true; // ƒêi 1 √¥ h·ª£p l·ªá\n      if (fromRow === startRow && dy === 2 * direction && !board[fromRow + direction][toCol]) {\n          return true; // ƒêi 2 √¥ t·ª´ v·ªã tr√≠ ban ƒë·∫ßu h·ª£p l·ªá (kh√¥ng nh·∫£y qua qu√¢n c·ªù)\n      }\n  }\n\n  // ƒÇn qu√¢n ch√©o (ch·ªâ khi c√≥ qu√¢n ƒë·ªãch ·ªü √¥ ƒë√≠ch)\n  if (dx === 1 && dy === direction && targetPiece) {\n      return true;\n  }\n\n  return false;\n};\n\n// ‚úÖ Xe (Rook) - ƒë·∫£m b·∫£o c√≥ th·ªÉ ƒÉn qu√¢n ƒë·ªëi th·ªß h·ª£p l·ªá\nconst isValidRookMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ‚úÖ M√£ (Knight) - kh√¥ng c·∫ßn s·ª≠a (n∆∞·ªõc ƒëi ƒë√£ ƒë√∫ng)\nconst isValidKnightMove = (dx, dy) => {\n  return (Math.abs(dx) === 2 && Math.abs(dy) === 1) || (Math.abs(dx) === 1 && Math.abs(dy) === 2);\n};\n\n// ‚úÖ T∆∞·ª£ng (Bishop) - ƒë·∫£m b·∫£o kh√¥ng b·ªã ch·∫∑n ƒë∆∞·ªùng ƒëi\nconst isValidBishopMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ‚úÖ H·∫≠u (Queen) - k·∫øt h·ª£p Xe & T∆∞·ª£ng\nconst isValidQueenMove = (fromRow, fromCol, toRow, toCol, board) => {\n  return (\n      isValidRookMove(fromRow, fromCol, toRow, toCol, board) ||\n      isValidBishopMove(fromRow, fromCol, toRow, toCol, board)\n  );\n};\n\n// ‚úÖ Vua (King) - gi·ªØ nguy√™n\nconst isValidKingMove = (dx, dy) => {\n  return Math.abs(dx) <= 1 && Math.abs(dy) <= 1;\n};\n\n// ‚úÖ S·ª≠a l·∫°i ki·ªÉm tra ƒë∆∞·ªùng ƒëi `isPathClear()`\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n\n  while (x !== toCol || y !== toRow) {\n      if (board[y][x] !== \"\") return false; // N·∫øu c√≥ qu√¢n c·ªù ch·∫∑n ƒë∆∞·ªùng, kh√¥ng h·ª£p l·ªá\n      x += dx;\n      y += dy;\n  }\n\n  return true;\n};\nconst findKingPosition = (board, isWhite) => {\n  const king = isWhite ? \"‚ôî\" : \"‚ôö\";\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] === king) return { row, col };\n    }\n  }\n  return null;\n};\nconst isKingInCheck = (board, isWhite) => {\n  const kingPos = findKingPosition(board, isWhite);\n  if (!kingPos) return false; // Kh√¥ng t√¨m th·∫•y vua (tr√°nh l·ªói)\n\n  const { row: kingRow, col: kingCol } = kingPos;\n\n  // Duy·ªát qua to√†n b·ªô b√†n c·ªù ƒë·ªÉ t√¨m qu√¢n ƒë·ªëi ph∆∞∆°ng c√≥ th·ªÉ chi·∫øu vua\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (!piece) continue; // √î tr·ªëng b·ªè qua\n\n      const isEnemy = \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece) !== isWhite;\n      if (isEnemy && isValidMove(piece, row, col, kingRow, kingCol, board)) {\n        return true; // N·∫øu c√≥ qu√¢n ƒë·ªãch c√≥ th·ªÉ ƒëi ƒë·∫øn v·ªã tr√≠ vua, vua ƒëang b·ªã chi·∫øu\n      }\n    }\n  }\n\n  return false; // Kh√¥ng c√≥ qu√¢n n√†o chi·∫øu vua\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}