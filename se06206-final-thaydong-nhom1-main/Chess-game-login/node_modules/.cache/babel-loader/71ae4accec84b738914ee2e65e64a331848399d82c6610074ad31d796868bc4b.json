{"ast":null,"code":"import { isValidMove } from \"./moveRules\";\n\n// üìç T√¨m v·ªã tr√≠ c·ªßa vua tr√™n b√†n c·ªù\nexport const findKingPosition = (board, isWhite) => {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] === (isWhite ? \"‚ôî\" : \"‚ôö\")) {\n        return {\n          row,\n          col\n        };\n      }\n    }\n  }\n  console.error(\"‚ùå Kh√¥ng t√¨m th·∫•y Vua tr√™n b√†n c·ªù!\");\n  return null;\n};\n\n// üìç Ki·ªÉm tra xem vua c√≥ b·ªã chi·∫øu kh√¥ng\nexport const isKingInCheck = (board, isWhite) => {\n  const kingPos = findKingPosition(board, isWhite);\n  if (!kingPos) return false;\n  const {\n    row: kingRow,\n    col: kingCol\n  } = kingPos;\n  const whitePieces = \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\";\n  const blackPieces = \"‚ôü‚ôú‚ôû‚ôù‚ôõ‚ôö\";\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (!piece) continue;\n      const isEnemy = isWhite ? blackPieces.includes(piece) : whitePieces.includes(piece);\n      if (isEnemy && isValidMove(piece, row, col, kingRow, kingCol, board)) {\n        console.log(`‚ö†Ô∏è Vua ƒëang b·ªã chi·∫øu b·ªüi qu√¢n ${piece} t·ª´ (${row}, ${col})`);\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// üìç Ki·ªÉm tra chi·∫øu h·∫øt (Checkmate)\nexport const isCheckmate = (board, isWhite) => {\n  if (!isKingInCheck(board, isWhite)) return false;\n  console.log(`üîé Ki·ªÉm tra chi·∫øu h·∫øt cho vua ${isWhite ? \"tr·∫Øng\" : \"ƒëen\"}...`);\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (!piece) continue;\n      const isFriendly = isWhite ? \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece) : \"‚ôü‚ôú‚ôû‚ôù‚ôõ‚ôö\".includes(piece);\n      if (!isFriendly) continue;\n      for (let newRow = 0; newRow < 8; newRow++) {\n        for (let newCol = 0; newCol < 8; newCol++) {\n          if (!isValidMove(piece, row, col, newRow, newCol, board)) continue;\n          const newBoard = board.map(r => [...r]);\n          newBoard[newRow][newCol] = piece;\n          newBoard[row][col] = \"\";\n          if (!isKingInCheck(newBoard, isWhite)) {\n            return false;\n          }\n        }\n      }\n    }\n  }\n  console.log(`üèÜ Chi·∫øu h·∫øt!`);\n  return true;\n};","map":{"version":3,"names":["isValidMove","findKingPosition","board","isWhite","row","col","console","error","isKingInCheck","kingPos","kingRow","kingCol","whitePieces","blackPieces","piece","isEnemy","includes","log","isCheckmate","isFriendly","newRow","newCol","newBoard","map","r"],"sources":["D:/se06206-final-thaydong-nhom1-main/se06206-final-thaydong-nhom1-main/Chess-game-login/src/utils/checkmate.js"],"sourcesContent":["import { isValidMove } from \"./moveRules\"; \r\n\r\n// üìç T√¨m v·ªã tr√≠ c·ªßa vua tr√™n b√†n c·ªù\r\nexport const findKingPosition = (board, isWhite) => {\r\n  for (let row = 0; row < 8; row++) {\r\n    for (let col = 0; col < 8; col++) {\r\n      if (board[row][col] === (isWhite ? \"‚ôî\" : \"‚ôö\")) {\r\n        return { row, col };\r\n      }\r\n    }\r\n  }\r\n  console.error(\"‚ùå Kh√¥ng t√¨m th·∫•y Vua tr√™n b√†n c·ªù!\");\r\n  return null;\r\n};\r\n\r\n// üìç Ki·ªÉm tra xem vua c√≥ b·ªã chi·∫øu kh√¥ng\r\nexport const isKingInCheck = (board, isWhite) => {\r\n  const kingPos = findKingPosition(board, isWhite);\r\n  if (!kingPos) return false;\r\n\r\n  const { row: kingRow, col: kingCol } = kingPos;\r\n  const whitePieces = \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\";\r\n  const blackPieces = \"‚ôü‚ôú‚ôû‚ôù‚ôõ‚ôö\";\r\n\r\n  for (let row = 0; row < 8; row++) {\r\n    for (let col = 0; col < 8; col++) {\r\n      const piece = board[row][col];\r\n      if (!piece) continue;\r\n\r\n      const isEnemy = isWhite ? blackPieces.includes(piece) : whitePieces.includes(piece);\r\n      if (isEnemy && isValidMove(piece, row, col, kingRow, kingCol, board)) {\r\n        console.log(`‚ö†Ô∏è Vua ƒëang b·ªã chi·∫øu b·ªüi qu√¢n ${piece} t·ª´ (${row}, ${col})`);\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n// üìç Ki·ªÉm tra chi·∫øu h·∫øt (Checkmate)\r\nexport const isCheckmate = (board, isWhite) => {\r\n  if (!isKingInCheck(board, isWhite)) return false;\r\n\r\n  console.log(`üîé Ki·ªÉm tra chi·∫øu h·∫øt cho vua ${isWhite ? \"tr·∫Øng\" : \"ƒëen\"}...`);\r\n\r\n  for (let row = 0; row < 8; row++) {\r\n    for (let col = 0; col < 8; col++) {\r\n      const piece = board[row][col];\r\n      if (!piece) continue;\r\n\r\n      const isFriendly = isWhite ? \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece) : \"‚ôü‚ôú‚ôû‚ôù‚ôõ‚ôö\".includes(piece);\r\n      if (!isFriendly) continue;\r\n\r\n      for (let newRow = 0; newRow < 8; newRow++) {\r\n        for (let newCol = 0; newCol < 8; newCol++) {\r\n          if (!isValidMove(piece, row, col, newRow, newCol, board)) continue;\r\n\r\n          const newBoard = board.map(r => [...r]);\r\n          newBoard[newRow][newCol] = piece;\r\n          newBoard[row][col] = \"\";\r\n\r\n          if (!isKingInCheck(newBoard, isWhite)) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  console.log(`üèÜ Chi·∫øu h·∫øt!`);\r\n  return true;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}