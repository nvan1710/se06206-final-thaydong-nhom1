{"ast":null,"code":"export const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board) => {\n  const dx = toCol - fromCol;\n  const dy = toRow - fromRow;\n\n  // Prevent moving to the same position\n  if (fromRow === toRow && fromCol === toCol) return false;\n\n  // Get the piece color\n  const isWhite = piece === piece.toUpperCase(); // White pieces are uppercase\n  const targetPiece = board[toRow][toCol];\n\n  // Prevent capturing same-color pieces\n  if (targetPiece && isWhite === (targetPiece === targetPiece.toUpperCase())) {\n    return false;\n  }\n  switch (piece.toLowerCase()) {\n    case \"♙\":\n      // White Pawn\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, true);\n    case \"♟\":\n      // Black Pawn\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, false);\n    case \"♖\":\n    case \"♜\":\n      // Rook\n      return isValidRookMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♘\":\n    case \"♞\":\n      // Knight\n      return isValidKnightMove(dx, dy);\n    case \"♗\":\n    case \"♝\":\n      // Bishop\n      return isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♕\":\n    case \"♛\":\n      // Queen\n      return isValidQueenMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♔\":\n    case \"♚\":\n      // King\n      return isValidKingMove(dx, dy);\n    default:\n      return false;\n  }\n};\n\n// Pawn movement\nconst isValidPawnMove = (fromRow, fromCol, toRow, toCol, board, isWhite) => {\n  const direction = isWhite ? -1 : 1;\n  const startRow = isWhite ? 6 : 1;\n  const dy = toRow - fromRow;\n  const dx = Math.abs(toCol - fromCol);\n  if (dx === 0) {\n    // Move forward one square\n    if (dy === direction && !board[toRow][toCol]) return true;\n    // Move forward two squares from starting position\n    if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol]) return true;\n  }\n\n  // Capture diagonally\n  if (dx === 1 && dy === direction && board[toRow][toCol]) return true;\n  return false;\n};\n\n// Rook movement\nconst isValidRookMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// Knight movement\nconst isValidKnightMove = (dx, dy) => {\n  return Math.abs(dx) === 2 && Math.abs(dy) === 1 || Math.abs(dx) === 1 && Math.abs(dy) === 2;\n};\n\n// Bishop movement\nconst isValidBishopMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// Queen movement (combines rook and bishop)\nconst isValidQueenMove = (fromRow, fromCol, toRow, toCol, board) => {\n  return isValidRookMove(fromRow, fromCol, toRow, toCol, board) || isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n};\n\n// King movement\nconst isValidKingMove = (dx, dy) => {\n  return Math.abs(dx) <= 1 && Math.abs(dy) <= 1;\n};\n\n// Checks if the path is clear (for Rook, Bishop, and Queen)\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x]) return false;\n    x += dx;\n    y += dy;\n  }\n  return true;\n};","map":{"version":3,"names":["isValidMove","piece","fromRow","fromCol","toRow","toCol","board","dx","dy","isWhite","toUpperCase","targetPiece","toLowerCase","isValidPawnMove","isValidRookMove","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","direction","startRow","Math","abs","isPathClear","sign","x","y"],"sources":["/root/se06206-final-thaydong-nhom1/Chess-game-login/src/utils/moveRules.js"],"sourcesContent":["export const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board) => {\n  const dx = toCol - fromCol;\n  const dy = toRow - fromRow;\n\n  // Prevent moving to the same position\n  if (fromRow === toRow && fromCol === toCol) return false;\n\n  // Get the piece color\n  const isWhite = piece === piece.toUpperCase(); // White pieces are uppercase\n  const targetPiece = board[toRow][toCol];\n\n  // Prevent capturing same-color pieces\n  if (targetPiece && (isWhite === (targetPiece === targetPiece.toUpperCase()))) {\n    return false;\n  }\n\n  switch (piece.toLowerCase()) {\n    case \"♙\": // White Pawn\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, true);\n    case \"♟\": // Black Pawn\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, false);\n    case \"♖\": case \"♜\": // Rook\n      return isValidRookMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♘\": case \"♞\": // Knight\n      return isValidKnightMove(dx, dy);\n    case \"♗\": case \"♝\": // Bishop\n      return isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♕\": case \"♛\": // Queen\n      return isValidQueenMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♔\": case \"♚\": // King\n      return isValidKingMove(dx, dy);\n    default:\n      return false;\n  }\n};\n\n// Pawn movement\nconst isValidPawnMove = (fromRow, fromCol, toRow, toCol, board, isWhite) => {\n  const direction = isWhite ? -1 : 1;\n  const startRow = isWhite ? 6 : 1;\n  const dy = toRow - fromRow;\n  const dx = Math.abs(toCol - fromCol);\n\n  if (dx === 0) {\n    // Move forward one square\n    if (dy === direction && !board[toRow][toCol]) return true;\n    // Move forward two squares from starting position\n    if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol]) return true;\n  }\n\n  // Capture diagonally\n  if (dx === 1 && dy === direction && board[toRow][toCol]) return true;\n\n  return false;\n};\n\n// Rook movement\nconst isValidRookMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// Knight movement\nconst isValidKnightMove = (dx, dy) => {\n  return (Math.abs(dx) === 2 && Math.abs(dy) === 1) || (Math.abs(dx) === 1 && Math.abs(dy) === 2);\n};\n\n// Bishop movement\nconst isValidBishopMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// Queen movement (combines rook and bishop)\nconst isValidQueenMove = (fromRow, fromCol, toRow, toCol, board) => {\n  return (\n    isValidRookMove(fromRow, fromCol, toRow, toCol, board) ||\n    isValidBishopMove(fromRow, fromCol, toRow, toCol, board)\n  );\n};\n\n// King movement\nconst isValidKingMove = (dx, dy) => {\n  return Math.abs(dx) <= 1 && Math.abs(dy) <= 1;\n};\n\n// Checks if the path is clear (for Rook, Bishop, and Queen)\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x]) return false;\n    x += dx;\n    y += dy;\n  }\n  return true;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}