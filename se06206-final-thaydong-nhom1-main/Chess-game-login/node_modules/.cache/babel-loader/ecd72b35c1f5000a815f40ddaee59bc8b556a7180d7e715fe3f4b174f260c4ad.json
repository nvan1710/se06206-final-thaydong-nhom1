{"ast":null,"code":"export const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board, turn, lastMove) => {\n  if (fromRow === toRow && fromCol === toCol) return false;\n  const isWhite = \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece);\n  if (turn === \"white\" && !isWhite || turn === \"black\" && isWhite) return false;\n  const targetPiece = board[toRow][toCol];\n  const isTargetWhite = targetPiece && \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(targetPiece);\n  if (targetPiece && isWhite === isTargetWhite) return false;\n  switch (piece) {\n    case \"‚ôô\":\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, true, lastMove);\n    case \"‚ôü\":\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, false, lastMove);\n    case \"‚ôñ\":\n    case \"‚ôú\":\n      return isValidRookMove(fromRow, fromCol, toRow, toCol, board);\n    case \"‚ôò\":\n    case \"‚ôû\":\n      return isValidKnightMove(toCol - fromCol, toRow - fromRow);\n    case \"‚ôó\":\n    case \"‚ôù\":\n      return isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n    case \"‚ôï\":\n    case \"‚ôõ\":\n      return isValidQueenMove(fromRow, fromCol, toRow, toCol, board);\n    case \"‚ôî\":\n    case \"‚ôö\":\n      return isValidKingMove(fromRow, fromCol, toRow, toCol, board);\n    default:\n      return false;\n  }\n};\n\n// üèá Knight move\nconst isValidKnightMove = (dx, dy) => {\n  return Math.abs(dx) === 2 && Math.abs(dy) === 1 || Math.abs(dx) === 1 && Math.abs(dy) === 2;\n};\n\n// üè∞ Rook move (straight lines)\nconst isValidRookMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// üèπ Bishop move (diagonal)\nconst isValidBishopMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// üëë Queen move (Rook + Bishop combined)\nconst isValidQueenMove = (fromRow, fromCol, toRow, toCol, board) => {\n  return isValidRookMove(fromRow, fromCol, toRow, toCol, board) || isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ‚öî King move (1 square + Castling)\nconst isValidKingMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) <= 1 && Math.abs(fromRow - toRow) <= 1) return true; // Normal King move\n  return isValidCastling(fromRow, fromCol, toRow, toCol, board); // Castling check\n};\n\n// üèá Pawn move (En Passant + Promotion)\nconst isValidPawnMove = (fromRow, fromCol, toRow, toCol, board, isWhite, lastMove) => {\n  const direction = isWhite ? -1 : 1;\n  const startRow = isWhite ? 6 : 1;\n  const promotionRow = isWhite ? 0 : 7;\n  const dy = toRow - fromRow;\n  const dx = Math.abs(toCol - fromCol);\n\n  // Normal forward move\n  if (dx === 0) {\n    if (dy === direction && !board[toRow][toCol]) {\n      return toRow === promotionRow ? \"promotion\" : true;\n    }\n    if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol] && !board[fromRow + direction][fromCol]) return true;\n  }\n\n  // Capture move\n  if (dx === 1 && dy === direction && board[toRow][toCol]) return true;\n\n  // En Passant\n  if (dx === 1 && dy === direction && (lastMove === null || lastMove === void 0 ? void 0 : lastMove.piece.toLowerCase()) === \"‚ôô\" && Math.abs(lastMove.fromRow - lastMove.toRow) === 2) {\n    if (lastMove.toRow === fromRow && lastMove.toCol === toCol) return \"en passant\";\n  }\n  return false;\n};\n\n// üè∞ Castling\nconst isValidCastling = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) !== 2 || fromRow !== toRow) return false;\n  const king = board[fromRow][fromCol];\n  const rookCol = toCol > fromCol ? 7 : 0;\n  const rook = board[fromRow][rookCol];\n  if (king !== \"‚ôî\" && king !== \"‚ôö\") return false;\n  if (rook !== \"‚ôñ\" && rook !== \"‚ôú\") return false;\n  if (!isPathClear(fromRow, fromCol, fromRow, rookCol, board)) return false;\n  return true;\n};\n\n// üìè Check if path is clear\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x]) return false;\n    x += dx;\n    y += dy;\n  }\n  return true;\n};\n\n// üîé Check detection\nexport const isKingInCheck = (turn, board) => {\n  let kingPos = null;\n  board.forEach((row, rIdx) => row.forEach((piece, cIdx) => {\n    if (turn === \"white\" && piece === \"‚ôî\" || turn === \"black\" && piece === \"‚ôö\") {\n      kingPos = {\n        row: rIdx,\n        col: cIdx\n      };\n    }\n  }));\n  return board.some((row, rIdx) => row.some((piece, cIdx) => {\n    if (piece && (turn === \"white\" && \"‚ôü‚ôú‚ôû‚ôù‚ôõ‚ôö\".includes(piece) || turn === \"black\" && \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece))) {\n      return isValidMove(piece, rIdx, cIdx, kingPos.row, kingPos.col, board, turn);\n    }\n    return false;\n  }));\n};","map":{"version":3,"names":["isValidMove","piece","fromRow","fromCol","toRow","toCol","board","turn","lastMove","isWhite","includes","targetPiece","isTargetWhite","isValidPawnMove","isValidRookMove","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","dx","dy","Math","abs","isPathClear","isValidCastling","direction","startRow","promotionRow","toLowerCase","king","rookCol","rook","sign","x","y","isKingInCheck","kingPos","forEach","row","rIdx","cIdx","col","some"],"sources":["/root/se06206-final-thaydong-nhom1/Chess-game-login/src/utils/moveRules.js"],"sourcesContent":["export const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board, turn, lastMove) => {\n  if (fromRow === toRow && fromCol === toCol) return false;\n\n  const isWhite = \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece);\n  if ((turn === \"white\" && !isWhite) || (turn === \"black\" && isWhite)) return false;\n\n  const targetPiece = board[toRow][toCol];\n  const isTargetWhite = targetPiece && \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(targetPiece);\n\n  if (targetPiece && isWhite === isTargetWhite) return false;\n\n  switch (piece) {\n    case \"‚ôô\": return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, true, lastMove);\n    case \"‚ôü\": return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, false, lastMove);\n    case \"‚ôñ\": case \"‚ôú\": return isValidRookMove(fromRow, fromCol, toRow, toCol, board);\n    case \"‚ôò\": case \"‚ôû\": return isValidKnightMove(toCol - fromCol, toRow - fromRow);\n    case \"‚ôó\": case \"‚ôù\": return isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n    case \"‚ôï\": case \"‚ôõ\": return isValidQueenMove(fromRow, fromCol, toRow, toCol, board);\n    case \"‚ôî\": case \"‚ôö\": return isValidKingMove(fromRow, fromCol, toRow, toCol, board);\n    default: return false;\n  }\n};\n\n// üèá Knight move\nconst isValidKnightMove = (dx, dy) => {\n  return (Math.abs(dx) === 2 && Math.abs(dy) === 1) || (Math.abs(dx) === 1 && Math.abs(dy) === 2);\n};\n\n// üè∞ Rook move (straight lines)\nconst isValidRookMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// üèπ Bishop move (diagonal)\nconst isValidBishopMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromRow - toRow) !== Math.abs(fromCol - toCol)) return false;\n  return isPathClear(fromRow, fromCol, toRow, toCol, board);\n};\n\n// üëë Queen move (Rook + Bishop combined)\nconst isValidQueenMove = (fromRow, fromCol, toRow, toCol, board) => {\n  return isValidRookMove(fromRow, fromCol, toRow, toCol, board) || isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n};\n\n// ‚öî King move (1 square + Castling)\nconst isValidKingMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) <= 1 && Math.abs(fromRow - toRow) <= 1) return true; // Normal King move\n  return isValidCastling(fromRow, fromCol, toRow, toCol, board); // Castling check\n};\n\n// üèá Pawn move (En Passant + Promotion)\nconst isValidPawnMove = (fromRow, fromCol, toRow, toCol, board, isWhite, lastMove) => {\n  const direction = isWhite ? -1 : 1;\n  const startRow = isWhite ? 6 : 1;\n  const promotionRow = isWhite ? 0 : 7;\n  const dy = toRow - fromRow;\n  const dx = Math.abs(toCol - fromCol);\n\n  // Normal forward move\n  if (dx === 0) {\n    if (dy === direction && !board[toRow][toCol]) {\n      return toRow === promotionRow ? \"promotion\" : true;\n    }\n    if (fromRow === startRow && dy === 2 * direction && !board[toRow][toCol] && !board[fromRow + direction][fromCol]) return true;\n  }\n\n  // Capture move\n  if (dx === 1 && dy === direction && board[toRow][toCol]) return true;\n\n  // En Passant\n  if (dx === 1 && dy === direction && lastMove?.piece.toLowerCase() === \"‚ôô\" && Math.abs(lastMove.fromRow - lastMove.toRow) === 2) {\n    if (lastMove.toRow === fromRow && lastMove.toCol === toCol) return \"en passant\";\n  }\n\n  return false;\n};\n\n// üè∞ Castling\nconst isValidCastling = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) !== 2 || fromRow !== toRow) return false;\n  const king = board[fromRow][fromCol];\n  const rookCol = toCol > fromCol ? 7 : 0;\n  const rook = board[fromRow][rookCol];\n\n  if (king !== \"‚ôî\" && king !== \"‚ôö\") return false;\n  if (rook !== \"‚ôñ\" && rook !== \"‚ôú\") return false;\n  if (!isPathClear(fromRow, fromCol, fromRow, rookCol, board)) return false;\n\n  return true;\n};\n\n// üìè Check if path is clear\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x]) return false;\n    x += dx;\n    y += dy;\n  }\n  return true;\n};\n\n// üîé Check detection\nexport const isKingInCheck = (turn, board) => {\n  let kingPos = null;\n  board.forEach((row, rIdx) =>\n    row.forEach((piece, cIdx) => {\n      if ((turn === \"white\" && piece === \"‚ôî\") || (turn === \"black\" && piece === \"‚ôö\")) {\n        kingPos = { row: rIdx, col: cIdx };\n      }\n    })\n  );\n\n  return board.some((row, rIdx) =>\n    row.some((piece, cIdx) => {\n      if (piece && ((turn === \"white\" && \"‚ôü‚ôú‚ôû‚ôù‚ôõ‚ôö\".includes(piece)) || (turn === \"black\" && \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\".includes(piece)))) {\n        return isValidMove(piece, rIdx, cIdx, kingPos.row, kingPos.col, board, turn);\n      }\n      return false;\n    })\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}