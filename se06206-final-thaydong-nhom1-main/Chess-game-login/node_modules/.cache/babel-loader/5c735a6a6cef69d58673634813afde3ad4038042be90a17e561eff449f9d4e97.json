{"ast":null,"code":"/**\r\n * @internal\r\n */\nconst NULL = 0;\n/**\r\n * @internal\r\n */\nconst LF = 10;\n/**\r\n * @internal\r\n */\nconst CR = 13;\n/**\r\n * @internal\r\n */\nconst COLON = 58;\n/**\r\n * This is an evented, rec descent parser.\r\n * A stream of Octets can be passed and whenever it recognizes\r\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\r\n *\r\n * All incoming Octets are fed into _onByte function.\r\n * Depending on current state the _onByte function keeps changing.\r\n * Depending on the state it keeps accumulating into _token and _results.\r\n * State is indicated by current value of _onByte, all states are named as _collect.\r\n *\r\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\r\n * imply that all lengths are considered in bytes (instead of string lengths).\r\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\r\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\r\n *\r\n * There is no peek function on the incoming data.\r\n * When a state change occurs based on an Octet without consuming the Octet,\r\n * the Octet, after state change, is fed again (_reinjectByte).\r\n * This became possible as the state change can be determined by inspecting just one Octet.\r\n *\r\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\r\n * otherwise it is determined by NULL terminator.\r\n *\r\n * Following the standards, the command and headers are converted to Strings\r\n * and the body is returned as Octets.\r\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\r\n *\r\n * This parser does not use Regular Expressions as that can only operate on Strings.\r\n *\r\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\r\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\r\n * is pushed.\r\n *\r\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\r\n * (which is protocol version specific), and convert body to text.\r\n *\r\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\nexport class Parser {\n  constructor(onFrame, onIncomingPing) {\n    this.onFrame = onFrame;\n    this.onIncomingPing = onIncomingPing;\n    this._encoder = new TextEncoder();\n    this._decoder = new TextDecoder();\n    this._token = [];\n    this._initState();\n  }\n  parseChunk(segment, appendMissingNULLonIncoming = false) {\n    let chunk;\n    if (typeof segment === 'string') {\n      chunk = this._encoder.encode(segment);\n    } else {\n      chunk = new Uint8Array(segment);\n    }\n    // See https://github.com/stomp-js/stompjs/issues/89\n    // Remove when underlying issue is fixed.\n    //\n    // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n    if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n      const chunkWithNull = new Uint8Array(chunk.length + 1);\n      chunkWithNull.set(chunk, 0);\n      chunkWithNull[chunk.length] = 0;\n      chunk = chunkWithNull;\n    }\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < chunk.length; i++) {\n      const byte = chunk[i];\n      this._onByte(byte);\n    }\n  }\n  // The following implements a simple Rec Descent Parser.\n  // The grammar is simple and just one byte tells what should be the next state\n  _collectFrame(byte) {\n    if (byte === NULL) {\n      // Ignore\n      return;\n    }\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      // Incoming Ping\n      this.onIncomingPing();\n      return;\n    }\n    this._onByte = this._collectCommand;\n    this._reinjectByte(byte);\n  }\n  _collectCommand(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.command = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaders;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _collectHeaders(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._setupCollectBody();\n      return;\n    }\n    this._onByte = this._collectHeaderKey;\n    this._reinjectByte(byte);\n  }\n  _reinjectByte(byte) {\n    this._onByte(byte);\n  }\n  _collectHeaderKey(byte) {\n    if (byte === COLON) {\n      this._headerKey = this._consumeTokenAsUTF8();\n      this._onByte = this._collectHeaderValue;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _collectHeaderValue(byte) {\n    if (byte === CR) {\n      // Ignore CR\n      return;\n    }\n    if (byte === LF) {\n      this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n      this._headerKey = undefined;\n      this._onByte = this._collectHeaders;\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _setupCollectBody() {\n    const contentLengthHeader = this._results.headers.filter(header => {\n      return header[0] === 'content-length';\n    })[0];\n    if (contentLengthHeader) {\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n      this._onByte = this._collectBodyFixedSize;\n    } else {\n      this._onByte = this._collectBodyNullTerminated;\n    }\n  }\n  _collectBodyNullTerminated(byte) {\n    if (byte === NULL) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _collectBodyFixedSize(byte) {\n    // It is post decrement, so that we discard the trailing NULL octet\n    if (this._bodyBytesRemaining-- === 0) {\n      this._retrievedBody();\n      return;\n    }\n    this._consumeByte(byte);\n  }\n  _retrievedBody() {\n    this._results.binaryBody = this._consumeTokenAsRaw();\n    try {\n      this.onFrame(this._results);\n    } catch (e) {\n      console.log(`Ignoring an exception thrown by a frame handler. Original exception: `, e);\n    }\n    this._initState();\n  }\n  // Rec Descent Parser helpers\n  _consumeByte(byte) {\n    this._token.push(byte);\n  }\n  _consumeTokenAsUTF8() {\n    return this._decoder.decode(this._consumeTokenAsRaw());\n  }\n  _consumeTokenAsRaw() {\n    const rawResult = new Uint8Array(this._token);\n    this._token = [];\n    return rawResult;\n  }\n  _initState() {\n    this._results = {\n      command: undefined,\n      headers: [],\n      binaryBody: undefined\n    };\n    this._token = [];\n    this._headerKey = undefined;\n    this._onByte = this._collectFrame;\n  }\n}","map":{"version":3,"names":["NULL","LF","CR","COLON","Parser","constructor","onFrame","onIncomingPing","_encoder","TextEncoder","_decoder","TextDecoder","_token","_initState","parseChunk","segment","appendMissingNULLonIncoming","chunk","encode","Uint8Array","length","chunkWithNull","set","i","byte","_onByte","_collectFrame","_collectCommand","_reinjectByte","_results","command","_consumeTokenAsUTF8","_collectHeaders","_consumeByte","_setupCollectBody","_collectHeaderKey","_headerKey","_collectHeaderValue","headers","push","undefined","contentLengthHeader","filter","header","_bodyBytesRemaining","parseInt","_collectBodyFixedSize","_collectBodyNullTerminated","_retrievedBody","binaryBody","_consumeTokenAsRaw","e","console","log","decode","rawResult"],"sources":["C:\\Users\\admin\\se06206-final-thaydong-nhom1\\se06206-final-thaydong-nhom1-main\\Chess-game-login\\node_modules\\@stomp\\stompjs\\src\\parser.ts"],"sourcesContent":["import { IRawFrameType } from './types.js';\r\n\r\n/**\r\n * @internal\r\n */\r\nconst NULL = 0;\r\n/**\r\n * @internal\r\n */\r\nconst LF = 10;\r\n/**\r\n * @internal\r\n */\r\nconst CR = 13;\r\n/**\r\n * @internal\r\n */\r\nconst COLON = 58;\r\n\r\n/**\r\n * This is an evented, rec descent parser.\r\n * A stream of Octets can be passed and whenever it recognizes\r\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\r\n *\r\n * All incoming Octets are fed into _onByte function.\r\n * Depending on current state the _onByte function keeps changing.\r\n * Depending on the state it keeps accumulating into _token and _results.\r\n * State is indicated by current value of _onByte, all states are named as _collect.\r\n *\r\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\r\n * imply that all lengths are considered in bytes (instead of string lengths).\r\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\r\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\r\n *\r\n * There is no peek function on the incoming data.\r\n * When a state change occurs based on an Octet without consuming the Octet,\r\n * the Octet, after state change, is fed again (_reinjectByte).\r\n * This became possible as the state change can be determined by inspecting just one Octet.\r\n *\r\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\r\n * otherwise it is determined by NULL terminator.\r\n *\r\n * Following the standards, the command and headers are converted to Strings\r\n * and the body is returned as Octets.\r\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\r\n *\r\n * This parser does not use Regular Expressions as that can only operate on Strings.\r\n *\r\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\r\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\r\n * is pushed.\r\n *\r\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\r\n * (which is protocol version specific), and convert body to text.\r\n *\r\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\r\nexport class Parser {\r\n  private readonly _encoder = new TextEncoder();\r\n  private readonly _decoder = new TextDecoder();\r\n\r\n  // @ts-ignore - it always has a value\r\n  private _results: IRawFrameType;\r\n\r\n  private _token: number[] = [];\r\n  private _headerKey: string | undefined;\r\n  private _bodyBytesRemaining: number | undefined;\r\n\r\n  // @ts-ignore - it always has a value\r\n  private _onByte: (byte: number) => void;\r\n\r\n  public constructor(\r\n    public onFrame: (rawFrame: IRawFrameType) => void,\r\n    public onIncomingPing: () => void\r\n  ) {\r\n    this._initState();\r\n  }\r\n\r\n  public parseChunk(\r\n    segment: string | ArrayBuffer,\r\n    appendMissingNULLonIncoming: boolean = false\r\n  ) {\r\n    let chunk: Uint8Array;\r\n\r\n    if (typeof segment === 'string') {\r\n      chunk = this._encoder.encode(segment);\r\n    } else {\r\n      chunk = new Uint8Array(segment);\r\n    }\r\n\r\n    // See https://github.com/stomp-js/stompjs/issues/89\r\n    // Remove when underlying issue is fixed.\r\n    //\r\n    // Send a NULL byte, if the last byte of a Text frame was not NULL.F\r\n    if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\r\n      const chunkWithNull = new Uint8Array(chunk.length + 1);\r\n      chunkWithNull.set(chunk, 0);\r\n      chunkWithNull[chunk.length] = 0;\r\n      chunk = chunkWithNull;\r\n    }\r\n\r\n    // tslint:disable-next-line:prefer-for-of\r\n    for (let i = 0; i < chunk.length; i++) {\r\n      const byte = chunk[i];\r\n      this._onByte(byte);\r\n    }\r\n  }\r\n\r\n  // The following implements a simple Rec Descent Parser.\r\n  // The grammar is simple and just one byte tells what should be the next state\r\n\r\n  private _collectFrame(byte: number): void {\r\n    if (byte === NULL) {\r\n      // Ignore\r\n      return;\r\n    }\r\n    if (byte === CR) {\r\n      // Ignore CR\r\n      return;\r\n    }\r\n    if (byte === LF) {\r\n      // Incoming Ping\r\n      this.onIncomingPing();\r\n      return;\r\n    }\r\n\r\n    this._onByte = this._collectCommand;\r\n    this._reinjectByte(byte);\r\n  }\r\n\r\n  private _collectCommand(byte: number): void {\r\n    if (byte === CR) {\r\n      // Ignore CR\r\n      return;\r\n    }\r\n    if (byte === LF) {\r\n      this._results.command = this._consumeTokenAsUTF8();\r\n      this._onByte = this._collectHeaders;\r\n      return;\r\n    }\r\n\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _collectHeaders(byte: number): void {\r\n    if (byte === CR) {\r\n      // Ignore CR\r\n      return;\r\n    }\r\n    if (byte === LF) {\r\n      this._setupCollectBody();\r\n      return;\r\n    }\r\n    this._onByte = this._collectHeaderKey;\r\n    this._reinjectByte(byte);\r\n  }\r\n\r\n  private _reinjectByte(byte: number) {\r\n    this._onByte(byte);\r\n  }\r\n\r\n  private _collectHeaderKey(byte: number): void {\r\n    if (byte === COLON) {\r\n      this._headerKey = this._consumeTokenAsUTF8();\r\n      this._onByte = this._collectHeaderValue;\r\n      return;\r\n    }\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _collectHeaderValue(byte: number): void {\r\n    if (byte === CR) {\r\n      // Ignore CR\r\n      return;\r\n    }\r\n    if (byte === LF) {\r\n      this._results.headers.push([\r\n        this._headerKey as string,\r\n        this._consumeTokenAsUTF8(),\r\n      ]);\r\n      this._headerKey = undefined;\r\n      this._onByte = this._collectHeaders;\r\n      return;\r\n    }\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _setupCollectBody() {\r\n    const contentLengthHeader = this._results.headers.filter(\r\n      (header: [string, string]) => {\r\n        return header[0] === 'content-length';\r\n      }\r\n    )[0];\r\n\r\n    if (contentLengthHeader) {\r\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\r\n      this._onByte = this._collectBodyFixedSize;\r\n    } else {\r\n      this._onByte = this._collectBodyNullTerminated;\r\n    }\r\n  }\r\n\r\n  private _collectBodyNullTerminated(byte: number): void {\r\n    if (byte === NULL) {\r\n      this._retrievedBody();\r\n      return;\r\n    }\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _collectBodyFixedSize(byte: number): void {\r\n    // It is post decrement, so that we discard the trailing NULL octet\r\n    if ((this._bodyBytesRemaining as number)-- === 0) {\r\n      this._retrievedBody();\r\n      return;\r\n    }\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _retrievedBody() {\r\n    this._results.binaryBody = this._consumeTokenAsRaw();\r\n\r\n    try {\r\n      this.onFrame(this._results);\r\n    } catch (e) {\r\n      console.log(\r\n        `Ignoring an exception thrown by a frame handler. Original exception: `,\r\n        e\r\n      );\r\n    }\r\n\r\n    this._initState();\r\n  }\r\n\r\n  // Rec Descent Parser helpers\r\n\r\n  private _consumeByte(byte: number) {\r\n    this._token.push(byte);\r\n  }\r\n\r\n  private _consumeTokenAsUTF8() {\r\n    return this._decoder.decode(this._consumeTokenAsRaw());\r\n  }\r\n\r\n  private _consumeTokenAsRaw() {\r\n    const rawResult = new Uint8Array(this._token);\r\n    this._token = [];\r\n    return rawResult;\r\n  }\r\n\r\n  private _initState() {\r\n    this._results = {\r\n      command: undefined,\r\n      headers: [],\r\n      binaryBody: undefined,\r\n    };\r\n\r\n    this._token = [];\r\n    this._headerKey = undefined;\r\n\r\n    this._onByte = this._collectFrame;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}