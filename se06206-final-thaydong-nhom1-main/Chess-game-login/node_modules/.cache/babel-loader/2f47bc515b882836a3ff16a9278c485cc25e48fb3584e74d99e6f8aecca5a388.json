{"ast":null,"code":"import { getValidMoves } from \"./moveRules\";\n\n// T√¨m v·ªã tr√≠ c·ªßa vua tr√™n b√†n c·ªù\nexport const findKingPosition = (board, isWhiteTurn) => {\n  const kingSymbol = isWhiteTurn ? \"‚ôî\" : \"‚ôö\";\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      if (board[row][col] === kingSymbol) {\n        return {\n          row,\n          col\n        };\n      }\n    }\n  }\n  return null;\n};\n\n// Ki·ªÉm tra xem vua c√≥ b·ªã chi·∫øu kh√¥ng\nexport const isKingInCheck = (board, isWhiteTurn) => {\n  const kingPos = findKingPosition(board, isWhiteTurn);\n  if (!kingPos) return false;\n  console.log(`üîç Ki·ªÉm tra chi·∫øu cho vua ${isWhiteTurn ? \"tr·∫Øng\" : \"ƒëen\"} t·∫°i (${kingPos.row}, ${kingPos.col})`);\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n\n      // N·∫øu l√† qu√¢n ƒë·ªëi ph∆∞∆°ng\n      if (piece && (isWhiteTurn ? \"‚ôü‚ôú‚ôû‚ôù‚ôõ‚ôö\" : \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\").includes(piece)) {\n        const moves = getValidMoves(piece, row, col, board);\n        if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {\n          console.log(`üî• Vua ${isWhiteTurn ? \"tr·∫Øng\" : \"ƒëen\"} b·ªã chi·∫øu b·ªüi ${piece} t·ª´ (${row}, ${col})`);\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Ki·ªÉm tra xem c√≥ th·ªÉ di chuy·ªÉn ƒë·ªÉ c·ª©u vua kh·ªèi chi·∫øu kh√¥ng\nexport const canKingEscape = (board, isWhiteTurn) => {\n  const kingPos = findKingPosition(board, isWhiteTurn);\n  if (!kingPos) return false;\n  const kingMoves = getValidMoves(board[kingPos.row][kingPos.col], kingPos.row, kingPos.col, board);\n  for (let move of kingMoves) {\n    let simulatedBoard = board.map(row => [...row]);\n    simulatedBoard[kingPos.row][kingPos.col] = \"\";\n    simulatedBoard[move.row][move.col] = isWhiteTurn ? \"‚ôî\" : \"‚ôö\";\n    if (!isKingInCheck(simulatedBoard, isWhiteTurn)) {\n      return true; // V·∫´n c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá\n    }\n  }\n  return false;\n};\n\n// Ki·ªÉm tra chi·∫øu h·∫øt (Checkmate)\nexport const isCheckmate = (board, isWhiteTurn) => {\n  if (!isKingInCheck(board, isWhiteTurn)) return false;\n  if (canKingEscape(board, isWhiteTurn)) return false;\n  console.log(`‚ôüÔ∏è Vua ${isWhiteTurn ? \"tr·∫Øng\" : \"ƒëen\"} kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá -> Checkmate!`);\n  return true;\n};","map":{"version":3,"names":["getValidMoves","findKingPosition","board","isWhiteTurn","kingSymbol","row","col","isKingInCheck","kingPos","console","log","piece","includes","moves","some","move","canKingEscape","kingMoves","simulatedBoard","map","isCheckmate"],"sources":["D:/se06206-final-thaydong-nhom1-main/se06206-final-thaydong-nhom1-main/Chess-game-login/src/utils/checkmate.js"],"sourcesContent":["import { getValidMoves } from \"./moveRules\";\r\n\r\n// T√¨m v·ªã tr√≠ c·ªßa vua tr√™n b√†n c·ªù\r\nexport const findKingPosition = (board, isWhiteTurn) => {\r\n  const kingSymbol = isWhiteTurn ? \"‚ôî\" : \"‚ôö\";\r\n\r\n  for (let row = 0; row < 8; row++) {\r\n    for (let col = 0; col < 8; col++) {\r\n      if (board[row][col] === kingSymbol) {\r\n        return { row, col };\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\n// Ki·ªÉm tra xem vua c√≥ b·ªã chi·∫øu kh√¥ng\r\nexport const isKingInCheck = (board, isWhiteTurn) => {\r\n  const kingPos = findKingPosition(board, isWhiteTurn);\r\n  if (!kingPos) return false; \r\n\r\n  console.log(`üîç Ki·ªÉm tra chi·∫øu cho vua ${isWhiteTurn ? \"tr·∫Øng\" : \"ƒëen\"} t·∫°i (${kingPos.row}, ${kingPos.col})`);\r\n\r\n  for (let row = 0; row < 8; row++) {\r\n    for (let col = 0; col < 8; col++) {\r\n      const piece = board[row][col];\r\n\r\n      // N·∫øu l√† qu√¢n ƒë·ªëi ph∆∞∆°ng\r\n      if (piece && (isWhiteTurn ? \"‚ôü‚ôú‚ôû‚ôù‚ôõ‚ôö\" : \"‚ôô‚ôñ‚ôò‚ôó‚ôï‚ôî\").includes(piece)) {\r\n        const moves = getValidMoves(piece, row, col, board);\r\n        if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {\r\n          console.log(`üî• Vua ${isWhiteTurn ? \"tr·∫Øng\" : \"ƒëen\"} b·ªã chi·∫øu b·ªüi ${piece} t·ª´ (${row}, ${col})`);\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n// Ki·ªÉm tra xem c√≥ th·ªÉ di chuy·ªÉn ƒë·ªÉ c·ª©u vua kh·ªèi chi·∫øu kh√¥ng\r\nexport const canKingEscape = (board, isWhiteTurn) => {\r\n  const kingPos = findKingPosition(board, isWhiteTurn);\r\n  if (!kingPos) return false; \r\n\r\n  const kingMoves = getValidMoves(board[kingPos.row][kingPos.col], kingPos.row, kingPos.col, board);\r\n  \r\n  for (let move of kingMoves) {\r\n    let simulatedBoard = board.map(row => [...row]); \r\n    simulatedBoard[kingPos.row][kingPos.col] = \"\";\r\n    simulatedBoard[move.row][move.col] = isWhiteTurn ? \"‚ôî\" : \"‚ôö\";\r\n\r\n    if (!isKingInCheck(simulatedBoard, isWhiteTurn)) {\r\n      return true; // V·∫´n c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n// Ki·ªÉm tra chi·∫øu h·∫øt (Checkmate)\r\nexport const isCheckmate = (board, isWhiteTurn) => {\r\n  if (!isKingInCheck(board, isWhiteTurn)) return false;\r\n\r\n  if (canKingEscape(board, isWhiteTurn)) return false;\r\n\r\n  console.log(`‚ôüÔ∏è Vua ${isWhiteTurn ? \"tr·∫Øng\" : \"ƒëen\"} kh√¥ng c√≥ n∆∞·ªõc ƒëi h·ª£p l·ªá -> Checkmate!`);\r\n  return true;\r\n};\r\n"],"mappings":"AAAA,SAASA,aAAa,QAAQ,aAAa;;AAE3C;AACA,OAAO,MAAMC,gBAAgB,GAAGA,CAACC,KAAK,EAAEC,WAAW,KAAK;EACtD,MAAMC,UAAU,GAAGD,WAAW,GAAG,GAAG,GAAG,GAAG;EAE1C,KAAK,IAAIE,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;IAChC,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;MAChC,IAAIJ,KAAK,CAACG,GAAG,CAAC,CAACC,GAAG,CAAC,KAAKF,UAAU,EAAE;QAClC,OAAO;UAAEC,GAAG;UAAEC;QAAI,CAAC;MACrB;IACF;EACF;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMC,aAAa,GAAGA,CAACL,KAAK,EAAEC,WAAW,KAAK;EACnD,MAAMK,OAAO,GAAGP,gBAAgB,CAACC,KAAK,EAAEC,WAAW,CAAC;EACpD,IAAI,CAACK,OAAO,EAAE,OAAO,KAAK;EAE1BC,OAAO,CAACC,GAAG,CAAC,6BAA6BP,WAAW,GAAG,OAAO,GAAG,KAAK,SAASK,OAAO,CAACH,GAAG,KAAKG,OAAO,CAACF,GAAG,GAAG,CAAC;EAE9G,KAAK,IAAID,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;IAChC,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;MAChC,MAAMK,KAAK,GAAGT,KAAK,CAACG,GAAG,CAAC,CAACC,GAAG,CAAC;;MAE7B;MACA,IAAIK,KAAK,IAAI,CAACR,WAAW,GAAG,QAAQ,GAAG,QAAQ,EAAES,QAAQ,CAACD,KAAK,CAAC,EAAE;QAChE,MAAME,KAAK,GAAGb,aAAa,CAACW,KAAK,EAAEN,GAAG,EAAEC,GAAG,EAAEJ,KAAK,CAAC;QACnD,IAAIW,KAAK,CAACC,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACV,GAAG,KAAKG,OAAO,CAACH,GAAG,IAAIU,IAAI,CAACT,GAAG,KAAKE,OAAO,CAACF,GAAG,CAAC,EAAE;UAC5EG,OAAO,CAACC,GAAG,CAAC,UAAUP,WAAW,GAAG,OAAO,GAAG,KAAK,iBAAiBQ,KAAK,QAAQN,GAAG,KAAKC,GAAG,GAAG,CAAC;UAChG,OAAO,IAAI;QACb;MACF;IACF;EACF;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA,OAAO,MAAMU,aAAa,GAAGA,CAACd,KAAK,EAAEC,WAAW,KAAK;EACnD,MAAMK,OAAO,GAAGP,gBAAgB,CAACC,KAAK,EAAEC,WAAW,CAAC;EACpD,IAAI,CAACK,OAAO,EAAE,OAAO,KAAK;EAE1B,MAAMS,SAAS,GAAGjB,aAAa,CAACE,KAAK,CAACM,OAAO,CAACH,GAAG,CAAC,CAACG,OAAO,CAACF,GAAG,CAAC,EAAEE,OAAO,CAACH,GAAG,EAAEG,OAAO,CAACF,GAAG,EAAEJ,KAAK,CAAC;EAEjG,KAAK,IAAIa,IAAI,IAAIE,SAAS,EAAE;IAC1B,IAAIC,cAAc,GAAGhB,KAAK,CAACiB,GAAG,CAACd,GAAG,IAAI,CAAC,GAAGA,GAAG,CAAC,CAAC;IAC/Ca,cAAc,CAACV,OAAO,CAACH,GAAG,CAAC,CAACG,OAAO,CAACF,GAAG,CAAC,GAAG,EAAE;IAC7CY,cAAc,CAACH,IAAI,CAACV,GAAG,CAAC,CAACU,IAAI,CAACT,GAAG,CAAC,GAAGH,WAAW,GAAG,GAAG,GAAG,GAAG;IAE5D,IAAI,CAACI,aAAa,CAACW,cAAc,EAAEf,WAAW,CAAC,EAAE;MAC/C,OAAO,IAAI,CAAC,CAAC;IACf;EACF;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA,OAAO,MAAMiB,WAAW,GAAGA,CAAClB,KAAK,EAAEC,WAAW,KAAK;EACjD,IAAI,CAACI,aAAa,CAACL,KAAK,EAAEC,WAAW,CAAC,EAAE,OAAO,KAAK;EAEpD,IAAIa,aAAa,CAACd,KAAK,EAAEC,WAAW,CAAC,EAAE,OAAO,KAAK;EAEnDM,OAAO,CAACC,GAAG,CAAC,UAAUP,WAAW,GAAG,OAAO,GAAG,KAAK,wCAAwC,CAAC;EAC5F,OAAO,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}