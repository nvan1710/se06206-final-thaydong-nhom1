{"ast":null,"code":"export const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board, turn, lastMove) => {\n  console.log(`Move check: ${piece} from (${fromRow},${fromCol}) to (${toRow},${toCol}), Turn: ${turn}`);\n  if (fromRow === toRow && fromCol === toCol) return false;\n  const isWhite = \"♙♖♘♗♕♔\".includes(piece);\n  if (turn === \"white\" && !isWhite || turn === \"black\" && isWhite) return false;\n  const targetPiece = board[toRow][toCol];\n  const isTargetWhite = targetPiece && \"♙♖♘♗♕♔\".includes(targetPiece);\n  if (targetPiece && isWhite === isTargetWhite) return false;\n  switch (piece) {\n    case \"♙\":\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, true, lastMove);\n    case \"♟\":\n      return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, false, lastMove);\n    case \"♖\":\n    case \"♜\":\n      return isValidRookMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♘\":\n    case \"♞\":\n      return isValidKnightMove(fromRow, fromCol, toRow, toCol);\n    case \"♗\":\n    case \"♝\":\n      return isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♕\":\n    case \"♛\":\n      return isValidQueenMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♔\":\n    case \"♚\":\n      return isValidKingMove(fromRow, fromCol, toRow, toCol, board, board);\n    default:\n      return false;\n  }\n};\nconst isValidKingMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(toCol - fromCol) <= 1 && Math.abs(toRow - fromRow) <= 1) return true;\n  return isValidCastling(fromRow, fromCol, toRow, toCol, board);\n};\nconst isValidCastling = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) !== 2 || fromRow !== toRow) return false;\n  const king = board[fromRow][fromCol];\n  const rookCol = toCol > fromCol ? 7 : 0; // Identify rook position for kingside or queenside\n  const rook = board[fromRow][rookCol];\n  if (king !== \"♔\" && king !== \"♚\") return false;\n  if (rook !== \"♖\" && rook !== \"♜\") return false;\n  if (!isPathClear(fromRow, fromCol, fromRow, rookCol, board)) return false;\n\n  // Ensure the king is not in check before, during, or after castling\n  if (isKingInCheck(king, board)) return false;\n  if (isKingInCheck(king, simulateMove(board, fromRow, fromCol, fromRow, fromCol + (toCol > fromCol ? 1 : -1)))) return false;\n  if (isKingInCheck(king, simulateMove(board, fromRow, fromCol, toRow, toCol))) return false;\n\n  // Move the rook automatically when castling\n  const newRookCol = toCol > fromCol ? toCol - 1 : toCol + 1;\n  board[fromRow][rookCol] = null;\n  board[fromRow][newRookCol] = rook;\n  return true;\n};\n\n// Simulate move to check if king will be in check after castling\nconst simulateMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const newBoard = board.map(row => row.slice()); // Clone the board\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol]; // Move piece\n  newBoard[fromRow][fromCol] = null; // Clear old position\n  return newBoard;\n};\nconst isValidPawnMove = (fromRow, fromCol, toRow, toCol, board, isWhite, lastMove) => {\n  const direction = isWhite ? -1 : 1;\n  const startRow = isWhite ? 6 : 1;\n  const promotionRow = isWhite ? 0 : 7;\n  const dy = toRow - fromRow;\n  const dx = Math.abs(toCol - fromCol);\n  const targetPiece = board[toRow][toCol];\n\n  // Normal forward move\n  if (dx === 0) {\n    if (dy === direction && !targetPiece) {\n      return toRow === promotionRow ? \"promotion\" : true;\n    }\n    if (fromRow === startRow && dy === 2 * direction && !targetPiece && !board[fromRow + direction][fromCol]) {\n      return true;\n    }\n  }\n\n  // Diagonal capture with promotion\n  if (dx === 1 && dy === direction && targetPiece) {\n    return toRow === promotionRow ? \"promotion\" : true;\n  }\n  return false;\n};\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x]) return false;\n    x += dx;\n    y += dy;\n  }\n  return true;\n};","map":{"version":3,"names":["isValidMove","piece","fromRow","fromCol","toRow","toCol","board","turn","lastMove","console","log","isWhite","includes","targetPiece","isTargetWhite","isValidPawnMove","isValidRookMove","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","Math","abs","isValidCastling","king","rookCol","rook","isPathClear","isKingInCheck","simulateMove","newRookCol","newBoard","map","row","slice","direction","startRow","promotionRow","dy","dx","sign","x","y"],"sources":["/root/se06206-final-thaydong-nhom1/Chess-game-login/src/utils/moveRules.js"],"sourcesContent":["export const isValidMove = (piece, fromRow, fromCol, toRow, toCol, board, turn, lastMove) => {\n  console.log(`Move check: ${piece} from (${fromRow},${fromCol}) to (${toRow},${toCol}), Turn: ${turn}`);\n\n  if (fromRow === toRow && fromCol === toCol) return false;\n\n  const isWhite = \"♙♖♘♗♕♔\".includes(piece);\n  if ((turn === \"white\" && !isWhite) || (turn === \"black\" && isWhite)) return false;\n\n  const targetPiece = board[toRow][toCol];\n  const isTargetWhite = targetPiece && \"♙♖♘♗♕♔\".includes(targetPiece);\n\n  if (targetPiece && isWhite === isTargetWhite) return false;\n\n  switch (piece) {\n    case \"♙\": return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, true, lastMove);\n    case \"♟\": return isValidPawnMove(fromRow, fromCol, toRow, toCol, board, false, lastMove);\n    case \"♖\": case \"♜\": return isValidRookMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♘\": case \"♞\": return isValidKnightMove(fromRow, fromCol, toRow, toCol);\n    case \"♗\": case \"♝\": return isValidBishopMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♕\": case \"♛\": return isValidQueenMove(fromRow, fromCol, toRow, toCol, board);\n    case \"♔\": case \"♚\": return isValidKingMove(fromRow, fromCol, toRow, toCol, board, board);\n    default: return false;\n  }\n};\n\nconst isValidKingMove = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(toCol - fromCol) <= 1 && Math.abs(toRow - fromRow) <= 1) return true;\n  return isValidCastling(fromRow, fromCol, toRow, toCol, board);\n};\n\nconst isValidCastling = (fromRow, fromCol, toRow, toCol, board) => {\n  if (Math.abs(fromCol - toCol) !== 2 || fromRow !== toRow) return false;\n\n  const king = board[fromRow][fromCol];\n  const rookCol = toCol > fromCol ? 7 : 0; // Identify rook position for kingside or queenside\n  const rook = board[fromRow][rookCol];\n\n  if (king !== \"♔\" && king !== \"♚\") return false;\n  if (rook !== \"♖\" && rook !== \"♜\") return false;\n  if (!isPathClear(fromRow, fromCol, fromRow, rookCol, board)) return false;\n\n  // Ensure the king is not in check before, during, or after castling\n  if (isKingInCheck(king, board)) return false;\n  if (isKingInCheck(king, simulateMove(board, fromRow, fromCol, fromRow, fromCol + (toCol > fromCol ? 1 : -1)))) return false;\n  if (isKingInCheck(king, simulateMove(board, fromRow, fromCol, toRow, toCol))) return false;\n\n  // Move the rook automatically when castling\n  const newRookCol = toCol > fromCol ? toCol - 1 : toCol + 1;\n  board[fromRow][rookCol] = null;\n  board[fromRow][newRookCol] = rook;\n\n  return true;\n};\n\n// Simulate move to check if king will be in check after castling\nconst simulateMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const newBoard = board.map(row => row.slice()); // Clone the board\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol]; // Move piece\n  newBoard[fromRow][fromCol] = null; // Clear old position\n  return newBoard;\n};\n\nconst isValidPawnMove = (fromRow, fromCol, toRow, toCol, board, isWhite, lastMove) => {\n  const direction = isWhite ? -1 : 1;\n  const startRow = isWhite ? 6 : 1;\n  const promotionRow = isWhite ? 0 : 7;\n  const dy = toRow - fromRow;\n  const dx = Math.abs(toCol - fromCol);\n  const targetPiece = board[toRow][toCol];\n\n  // Normal forward move\n  if (dx === 0) {\n    if (dy === direction && !targetPiece) {\n      return toRow === promotionRow ? \"promotion\" : true;\n    }\n    if (fromRow === startRow && dy === 2 * direction && !targetPiece && !board[fromRow + direction][fromCol]) {\n      return true;\n    }\n  }\n\n  // Diagonal capture with promotion\n  if (dx === 1 && dy === direction && targetPiece) {\n    return toRow === promotionRow ? \"promotion\" : true;\n  }\n\n  return false;\n};\n\nconst isPathClear = (fromRow, fromCol, toRow, toCol, board) => {\n  const dx = Math.sign(toCol - fromCol);\n  const dy = Math.sign(toRow - fromRow);\n  let x = fromCol + dx;\n  let y = fromRow + dy;\n\n  while (x !== toCol || y !== toRow) {\n    if (board[y][x]) return false;\n    x += dx;\n    y += dy;\n  }\n  return true;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}